Исходные данные: массив позиций узлов p[i] с i = 1...n, целевая позиция t и значения дистанций между сопряжёнными узлами.
d[i] = | p[i+1] - p[i] | for i = 1, ... , n-1
Выходные данные: Новые позиции p[i],
i = 1...n

//Дистанция между корнем и целью
dist = | p[1] - t |
//Проверяем достижимость цели

if dist > d[1] + d[2] + ... + d[n-1]
{
    //цель недостижима
    for i = 1, ..., n-1 do
    {
        //Найдем дистанцию r[i] между целью t и узлом p[i]
        r[i] = | t - p[i] |
        lambda[i] = d[i] / r[i]
        //Находим новую позицию узла p[i]
        p[i+1] = (1 - lambda[i]) * p[i] + lambda[i] * t
   }
}
else
{
    //Дель достижима; т.о. b будет новой позицией узла p[1]
    b = p[1]
    //Проверяем, не выше ли дистанция между конечным узлом p[n] и
    //целевой позицией t значения терпимости (tolerance)
    DIFa = | p[n] - t |
    while DIFa > tol do
    {
         //Этап 1 : прямое следование
         //Устанавливаем конечный узел p[n] в качестве цели (вероятно, имелось ввиду "ставим на позицию цели" - прим. перев.)
         p[n] = t
         for i=n -1 , ..., 1 do
         {
                //Получаем расстояние r[i] между узлом p[i] и новой позицией p[i+1]
                r[i] = | p[i+1] - p[i] |
                lambda[i] = d[i] / r[i]
                //Вычисляем новую позицию  узла p[i]
                p[i] = ( 1 - lambda[i]) * p[i+1] + lambda[i] * p[i]
         }
         //Этап 2: обратное следование
         //Устанавливаем корневому элементу p[1] начальную позицию
         p[i] = b
         for i=1 ,..., n - 1 do
         {
              //Получаем дистанцию r[i] между узлом p[i+1] и позицией p[i]
              r[i] = | p[i+1] - p[i] |
              lambda[i] = d[i] / r[i]
              //Получаем новую позицию p[i]
              p[i+1] = (1-lambda[i]) * p[i] + lambda[i] * p[i+1]
         }
         DIFa = | p[n] - t |
    }
}